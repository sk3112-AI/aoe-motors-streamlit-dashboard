--- dashboard.py
+++ dashboard.py
@@ -123,7 +123,35 @@

@@
-def check_notes_relevance(text):
-    # existing logic
-    pass
+def check_notes_relevance(text):
+    # existing logic (unchanged)
+    pass

+# --- New: Suggest Offer ---
+def suggest_offer(context):
+    prompt = f\"\"\"
+You are an automotive sales advisor. Given:
+- Current vehicle: {context['current_vehicle']}
+- Interested vehicle: {context['interested_vehicle']}
+- Lead score: {context['lead_score_text']} ({context['numeric_lead_score']})
+- Sales notes: {context['sales_notes']}
+Recommend the next best action (financing, discounts, extended warranty, roadside assistance, etc.) differentiated by lead tier, and justify briefly.
+\"\"\"
+    resp = openai_client.chat.completions.create(
+        model=\"gpt-3.5-turbo\",
+        messages=[
+            {\"role\":\"system\",\"content\":\"You are a helpful sales advisor.\"},
+            {\"role\":\"user\",\"content\":prompt}
+        ],
+        temperature=0.7
+    )
+    return resp.choices[0].message.content.strip()
+
+
+# --- New: Talking Points ---
+def generate_talking_points(context):
+    prompt = f\"\"\"
+You are a sales coach. The lead has:
+- Current vehicle: {context['current_vehicle']}
+- Interested vehicle: {context['interested_vehicle']}
+- Lead score: {context['lead_score_text']} ({context['numeric_lead_score']})
+- Sales notes: {context['sales_notes']}
+Provide 5 concise bullet-point talking points for an initial call.
+\"\"\"
+    resp = openai_client.chat.completions.create(
+        model=\"gpt-3.5-turbo\",
+        messages=[
+            {\"role\":\"system\",\"content\":\"You generate talking points.\"},
+            {\"role\":\"user\",\"content\":prompt}
+        ],
+        temperature=0.7
+    )
+    return resp.choices[0].message.content.strip()

@@
-def interpret_and_query(query, df, start_date, end_date):
-    # existing logic...
-    ...
-    return ...
+def interpret_and_query(query, df, start_date, end_date):
+    # 1. identify tier if mentioned
+    tier = None
+    for t in [\"hot\",\"warm\",\"cold\"]:
+        if t in query.lower():
+            tier = t.title()
+
+    # 2. derive period bounds
+    ql = query.lower()
+    if \"today\" in ql:
+        pd_start = pd_end = datetime.now().date()
+    elif \"yesterday\" in ql:
+        pd_start = pd_end = datetime.now().date() - timedelta(days=1)
+    elif \"last week\" in ql:
+        pd_end = datetime.now().date()
+        pd_start = pd_end - timedelta(days=7)
+    else:
+        pd_start, pd_end = start_date, end_date
+
+    # 3. filter
+    mask = df['booking_timestamp'].dt.date.between(pd_start, pd_end)
+    if tier:
+        mask &= (df['lead_score'].str.title() == tier)
+    subset = df[mask]
+
+    # 4. build response
+    count = subset.shape[0]
+    if tier and count == 0:
+        return f\"No {tier} leads between {pd_start} and {pd_end}. Please adjust your date filters.\"
+    if tier:
+        return f\"{count} {tier} leads between {pd_start} and {pd_end}.\"
+    return f\"{df.shape[0]} leads between {pd_start} and {pd_end}.\"


